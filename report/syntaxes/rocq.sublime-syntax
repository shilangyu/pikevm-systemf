%YAML 1.2
---
# Generated by Gemini Thinking 3
name: Rocq
file_extensions:
  - v
scope: source.rocq

variables:
  # Reusable patterns
  ident: "[a-zA-Z_][a-zA-Z0-9_']"

contexts:
  main:
    - include: comments
    - include: strings
    - include: attributes
    - include: sorts
    - include: ltac-special
    - include: keywords-gallina
    - include: keywords-vernacular
    - include: tactics
    - include: operators
    - include: constants
    - include: common-types
    - include: common-constructors
    - include: identifiers

  comments:
    - match: \(\*
      push:
        - meta_scope: comment.block.rocq
        - match: \*\)
          pop: true
        - include: comments

  strings:
    - match: '"'
      push:
        - meta_scope: string.quoted.double.rocq
        - match: '"'
          pop: true
        - match: '""'
          scope: constant.character.escape.rocq

  attributes:
    - match: \#\[
      push:
        - meta_scope: meta.attribute.rocq
        - match: \]
          pop: true
        - include: strings
        - match: ","
          scope: punctuation.separator.rocq
        - match: ([a-zA-Z0-9_]+)(\=)?
          captures:
            1: entity.other.attribute-name.rocq
            2: punctuation.separator.key-value.rocq

  sorts:
    - match: \b(Prop|Set|Type|SProp)\b
      scope: support.type.sort.rocq

  # Gallina Term Keywords
  keywords-gallina:
    - match: \b(forall|fun|exists(?:!)?|match|with|end|as|in|let|if|then|else|return|fix|cofix|struct)\b
      scope: keyword.control.gallina.rocq

  # Rocq Vernacular Commands
  keywords-vernacular:
    # Modifiers
    - match: \b(Global|Local|Polymorphic|Monomorphic|Cumulative|Private|NonCumulative|Program)\s+
      scope: storage.modifier.rocq
    # Definitions that introduce a new name
    - match: \b(Theorem|Lemma|Fact|Remark|Corollary|Proposition|Property|Goal|Definition|Example|Fixpoint|CoFixpoint|Function|Inductive|CoInductive|Record|Structure|Class|Instance|Context|Axiom|Parameter|Conjecture|Hypothesis|Variable|Variables|Scheme|Variant)\b\s*({{ident}}*)?
      captures:
        1: storage.type.vernacular.rocq
        2: entity.name.function.rocq
    # Notation and Scopes
    - match: \b(Notation|Infix|Reserved\s+Notation|Delimit\s+Scope|Bind\s+Scope|Open\s+Scope|Close\s+Scope|Arguments)\b
      scope: keyword.other.notation.rocq
    # Module system
    - match: \b(Module|Section|Module\s+Type)\b\s*({{ident}}*)?
      captures:
        1: storage.type.namespace.rocq
        2: entity.name.namespace.rocq
    - match: \b(End|Import|Export|Include|Require(\s+Import|\s+Export|\s+Qualified)?)\b
      scope: keyword.control.import.rocq
    # Proof management
    - match: \b(Proof|Qed|Defined|Admitted|Abort|Save)\b\.
      scope: keyword.control.proof.rocq
    # Commands
    - match: \b(Check|Print|Eval|Compute|Search|SearchAbout|Locate|About|Hint|Generic|Generalizable|Add|Remove)\b
      scope: keyword.other.command.rocq
    # Settings
    - match: \b((?:Set|Unset)\s+[a-zA-Z][a-zA-Z0-9_]*)\b
      scope: keyword.other.setting.rocq

  # Ltac specific constructs
  ltac-special:
    - match: \b(Ltac)\b\s*({{ident}}*)?
      captures:
        1: storage.type.ltac.rocq
        2: entity.name.function.ltac.rocq
    # "match goal with" and context matching
    - match: \bmatch\s+goal\s+with\b
      scope: keyword.control.ltac.rocq
    - match: \b(context|lazymatch|multimatch)\b
      scope: keyword.control.ltac.rocq
    - match: \|-
      scope: keyword.operator.turnstile.rocq

  # Extended Tactics List
  tactics:
    # Basic tactics
    - match: \b(intros?|apply|assumption|exact|reflexivity|destruct|induction|inversion|inversion_clear|rewrite|subst|replace|unfold|simpl|red|cbv|lazy|compute|vm_compute|native_compute|pattern|cases|elim|case|case_eq|fix|cofix|constructor|split|left|right|exists|assert|pose|set|remember|specialize|generalize|clear|revert|move|rename|hnf|simple\s+inversion)\b
      scope: keyword.other.tactic.rocq
    # Automated tactics
    - match: \b(auto|eauto|trivial|tauto|intuition|lia|nia|lra|ring|field|fourier|omega|romega|now|easy|contradiction|contradict|congruence|discriminate|injection|decide\s+equality)\b
      scope: keyword.other.tactic.automated.rocq
    # Advanced/E-tactics
    - match: \b(eapply|eassumption|eexists|esplit|econstructor|erewrite|edestruct|einduction|evar|instantiate)\b
      scope: keyword.other.tactic.evar.rocq
    # Tacticals (control flow in tactics)
    - match: \b(fail|try|repeat|do|progress|first|solve|info_eauto|info_auto|abstract|unshelve|cycle|swap|revgoals|guard)\b
      scope: keyword.control.tactic.rocq

  operators:
    # Arrows and logical connectives
    - match: (->|=>|<-|<->|\\/|/\\|~|:)
      scope: keyword.operator.logical.rocq
    # Equality and assignment
    - match: (:=|==|<>|=)
      scope: keyword.operator.assignment.rocq
    # Common mathematical/functional operators
    - match: (\+|\-|\*|\/|\+\+|::|@|âˆ˜|\^)
      scope: keyword.operator.arithmetic.rocq
    # Scoping and composition
    - match: (%|&)
      scope: keyword.operator.scope.rocq
    # Punctuation
    - match: \.
      scope: punctuation.terminator.rocq
    - match: ;
      scope: punctuation.terminator.tactic.rocq
    - match: \|
      scope: punctuation.separator.pipe.rocq
    - match: \{(?!\|)|(?<!\|)\}
      scope: punctuation.section.braces.rocq
    - match: (\[|\]|\(|\))
      scope: punctuation.section.parens.rocq

  constants:
    # Hex literal
    - match: \b0x[0-9a-fA-F]+\b
      scope: constant.numeric.hex.rocq
    # Binary literal
    - match: \b0b[01]+\b
      scope: constant.numeric.binary.rocq
    # Decimal literal
    - match: \b\d+\b
      scope: constant.numeric.decimal.rocq
    - match: \b(true|false)\b
      scope: constant.language.boolean.rocq
    - match: \b(tt)\b
      scope: constant.language.unit.rocq

  common-types:
    - match: \b(option|list|bool|nat|unit|prod|sum|eq|positive|string|ascii|byte)\b
      scope: support.type.builtin.rocq

  common-constructors:
    # option constructors
    - match: \b(Some|None)\b
      scope: constant.language.option.rocq
    # list constructors
    - match: \b(nil|cons)\b
      scope: constant.language.list.rocq
    # nat constructors
    - match: \b(S)\b
      scope: constant.language.nat.rocq
    # sum constructors
    - match: \b(inl|inr)\b
      scope: constant.language.sum.rocq
    # pair constructor
    - match: \b(pair)\b
      scope: constant.language.prod.rocq
    # eq constructor
    - match: \b(eq_refl|refl_equal)\b
      scope: constant.language.eq.rocq

  identifiers:
    - match: \b{{ident}}*\b
      scope: variable.other.rocq
