%YAML 1.2
---
# Generated by Gemini Thinking 3
name: Modern Regexp (Enhanced)
scope: source.regexp
file_extensions: [re, regex]

contexts:
  main:
    # (optionally) Look for the opening slash of the JavaScript-style regex literal
    - match: "(?:/)?"
      scope: punctuation.definition.string.begin.regexp
      push: slash_regex

  slash_regex:
    # 1. Look for the closing slash
    - match: "/"
      scope: punctuation.definition.string.end.regexp
      set: regex_flags

    # 2. Include the original regex highlighting logic
    - include: regex_body

  regex_flags:
    # Match optional flags (e.g., g, i, m, y, u) after the closing slash
    - match: "[a-zA-Z]+"
      scope: keyword.other.flags.regexp
      pop: true
    # If no flags follow, immediately pop back to the parent context
    - match: ""
      pop: true

  regex_body:
    # Comments (Extended mode #)
    - match: '(?<!\\)#.*$'
      scope: comment.line.number-sign.regexp

    # Backreferences (Numeric: \1, \2...)
    - match: '\\[1-9][0-9]*'
      scope: keyword.other.backreference.numeric.regexp

    # Backreferences (Named: \k<name>, \g<name>, (?P=name))
    - match: '(?i)(\\k|\\g)(<|[<{])([a-z_][a-z0-9_]*)([>|}>])'
      captures:
        1: keyword.other.backreference.named.regexp
        2: punctuation.definition.reference.begin.regexp
        3: variable.other.backreference.regexp
        4: punctuation.definition.reference.end.regexp

    - match: '(?i)(\(\?P=)([a-z_][a-z0-9_]*)(\))'
      captures:
        1: keyword.other.backreference.named.regexp
        2: variable.other.backreference.regexp
        3: punctuation.definition.reference.end.regexp

    # Anchors and Boundaries
    - match: '\\[bBAGZz]|[\^$]'
      scope: keyword.control.anchor.regexp

    # Built-in Character Classes (\d, \w, \s, \D, \W, \S)
    - match: '\\[dDwWsS]'
      scope: support.type.class.builtin.regexp

    # Unicode Properties (e.g., \p{L})
    - match: '\\[pP]\{[a-zA-Z_]+\}'
      scope: support.constant.unicode.regexp

    # Escaped Characters (General)
    # This correctly handles \/ so it doesn't trigger the closing slash early
    - match: '\\.'
      scope: constant.character.escape.regexp

    # Character Classes [...]
    - match: '\[\^?'
      scope: punctuation.definition.character-class.begin.regexp
      push: char_class

    # Quantifiers
    - match: '[*+?]\??'
      scope: keyword.operator.quantifier.regexp
    - match: '\{\d+(?:,\d*)?\}\??'
      scope: keyword.operator.quantifier.range.regexp

    # Groups and Lookarounds
    - match: '\('
      scope: punctuation.definition.group.begin.regexp
      push: group_internals

    - match: '\)'
      scope: punctuation.definition.group.end.regexp

    # Alternation (The Pipe |)
    - match: '\|'
      scope: keyword.operator.logical.regexp

  char_class:
    - meta_scope: constant.other.character-class.set.regexp
    - match: '\]'
      scope: punctuation.definition.character-class.end.regexp
      pop: true
    # POSIX classes inside sets, e.g., [:alpha:]
    - match: '\[:[a-z]+:\]'
      scope: support.class.posix.regexp
    - match: '\\.'
      scope: constant.character.escape.regexp
    - match: "-"
      scope: punctuation.separator.range.regexp

  group_internals:
    # Named Group Definitions: (?P<name>...) or (?<name>...)
    - match: '\?(?:P?<([a-zA-Z_][a-zA-Z0-9_]*)>)'
      captures:
        0: keyword.control.group.regexp
        1: variable.other.group.name.regexp
      pop: true
    # Lookarounds and Non-capturing groups
    - match: '\?(?:[:=!>]|<=|<!|#)'
      scope: keyword.control.group.assertion.regexp
      pop: true
    # Default to standard capturing groups
    - match: "(?=[^?])"
      pop: true
