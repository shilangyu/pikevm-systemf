#import "/prelude.typ": *
#import "data.typ": *

= Prefix acceleration of the PikeVM <sec:prefix-acceleration>

In this chapter we implement a practical optimization based on the literals extracted from regexes. During the runtime of a regex engine, we want to skip positions of the haystack that cannot possibly lead to a match. The information from literals gives us an under-approximation of which positions cannot lead to a match. @thm:correctness-extract-literal-prefix-contra states a condition which can determine positions of the haystack where the match cannot exist. Using that, we want to implement prefix acceleration. Unfortunately, we quickly realize that it is quite unclear how to implement prefix acceleration if we treat the regex engine as a black box while wanting to preserve the runtime asymptotic characteristics. To notice the problem we must discuss the difference between *anchored* and *unanchored* matching.

Until this point, the semantics of matching we have presented correspond to the questions of _does_ a regex match a haystack #underline[exactly] at this current position and if so, _how_? Let us illustrate this by introducing a running example. We want to match the regex #ex-r against the haystack #s(). Say we want to check if the regex matches the haystack at the position marked by the arrow #s(position: 0). The answer is no, we fail to match due to the missing #hay[w] which required by the regex. What about at #s(position: 3)? Also not, the regex requires #hay[a] to be present at the starting position. Finally, what about at #s(position: 9)? Here we succeed with the matching being the substring #hay[abeww]. Each time, we have performed an *anchored* match. Approaching the specification of how matching works from the angle of anchored matching gives rise to cleaner semantics hence why these serve as the basis of formalization. In practice however, we are much more interested in *unanchored* matching, which asks the question of _does_ a regex match #underline[anywhere] in the haystack and if so, _how_? Since we are interested in #TODO[leftmost greedy semantics][Reference background about this], we specifically care about the leftmost match. Before this work, the engines which were formalized in Linden were anchored ones. Performing unanchored matching on our running example even at the start position of the haystack would succeed since as we saw there is a match at the end of the string, #s(match: regex(ex-r-src)).

Luckily, every anchored engine can be easily adjusted to perform unanchored matching. Say we want to find the unanchored match of the regex `r`. Instead of running the anchored engine with `r`, we run it with ```re /[^]*?r/```. The prepended `[^]*?` construct is called the @lazy-prefix:intro. Recall that the character descriptor `[^]` matches any character. This character descriptor is iterated an arbitrary number of times (`*`) in a lazy manner (`?`). This means matching `r` always has highest priority, but the lazy prefix allows us to advance the haystack by one each time `r` failed to match! As soon as `r` matches, we count this as the result.#note[This simplified explanation is made formal and proven true in @sec:engine-interface.]

Let us now assume we have access to a black-box anchored regex engine with a runtime characteristic which is of interest to us, namely being linear in the size of the regex and the haystack. We want to use it together with prefix acceleration to perform unanchored matching while staying linear. For now we can assume that in isolation, prefix acceleration is also linear. This assumption is made formal and proven true in @sec:prefix-acceleration-complexity. We immediately run into a limitation: we are allowed to invoke this engine only #underline[a constant amount of times]! Otherwise, the runtime complexity of our algorithm would be degraded. On the other hand, when we run the anchored engine with the lazy prefix, the engine will run until the exhaustion of the haystack not giving us any opportunities to perform acceleration. In fact, the best strategy which is known under this block-box assumption is to perform prefix acceleration a single time at the start, and from that found position run the anchored engine with the lazy prefix. This strategy is formalized and proven correct in @sec:literal-optimizations. This strategy is unsatisfactory since it allows us to skip positions in the haystack only once. We must thus dive into the internals of an engine to take full advantage of prefix acceleration.

We start by presenting the most popular linear regex engine called PikeVM in @sec:pikevm. Next in @sec:unanchored-pikevm, we introduce a new version of the PikeVM which works as an unanchored engine by integrating prefix acceleration. Then, we prove that the resulting engine retains the linear runtime characteristics in @sec:prefix-acceleration-complexity. Finally, by diving deeper into Linden we discuss the proof of correctness of this new unanchored PikeVM in @sec:unanchored-pikevm-correctness.

#include "pikevm.typ"
#include "unanchored_pikevm.typ"
#include "complexity_analysis.typ"
#include "correctness.typ"
